### 项目辅助翻译工具

这是我自己写的一个小脚本，用于辅助翻译开源项目

由于部分开源项目并未使用本地化功能提供多语言支持，因此需要手动替换被硬编码的UI内容

本项目通过设计规则文件来批量处理以上需求

### 如何使用

#### 前置条件

本脚本使用`Python`编写，因此在运行前你需要准备好`Python`运行环境

#### 命令行参数

本脚本通过命令行进行调用，命令行参数如下：

```text
usage: translator.py SOURCE [-r TARGET_ROOT]

positional arguments:
  SOURCE                规则文件地址，或者包含规则文件的文件夹

options:
  -r TARGET_ROOT        目标文件的根目录 (可选)
```

第一个参数是规则文件的地址

规则文件是包含了翻译所需的一系列数据的文本文件，主要的内容是替换规则

本脚本支持解析给定路径的规则文件，但更一般的是给定包含大量规则文件的文件夹，以实现批量操作

解析文件夹时会递归搜索，因此即使有多层文件夹嵌套也不会影响规则文件的解析，但是请注意，目前脚本暂不支持跳过文件夹中不符合规则文件格式的文件

第二个参数是可选的目标文件的根目录

目标文件是包含硬编码内容的待翻译的文件，该文件的地址在规则文件中通过关键字进行定义

但是为了便于编写，规则文件中定义的往往是相对地址，因此需要额外提供一个在转换为绝对地址中所需要的根目录地址

因此，以下是一个读取当前目录下规则文件的例子：

```commandline
translator.py ./rule.txt
```

这是一个读取文件夹内所有规则文件的例子：

```commandline
translator.py ./rules_folder
```

最后是一个包含了目标根目录的例子

```commandline
translator.py ./rules_folder -r /app/target
```

### 规则文件

规则文件是包含了翻译所需的元数据，以及替换所需的内容的文本文件

规则文件不限制后缀名，脚本将强制视为文本读取，注意保存的格式为`utf-8`

目前规则文件主要由`关键字行`、`注释行`、`空行`以及`规则行`四部分组成，其中脚本在读取时会首先移除所有的`空行`，因此其不会影响到接下来的内容

#### 关键字行

关键字行用于描述翻译中的各种杂项数据，其由`@`开头，以`=`划分键值对

一个关键字的例子是

```text
@KEYWORD_NAME=KEYWORD_VALUE
```

如上所述，该关键字的值是`KEYWORD_NAME`，而值是`KEYWORD_VALUE`

大部分情况下的关键字都对脚本工作没有实际意义，更多的是添加一些与翻译者有关的信息，例如

```text
@AUTHOR=作者
@VERSION=翻译版本号
```

你也可以添加自定义的关键字来描述其他内容，这不会影响脚本的执行，但请注意不要在关键字的值中添加`=`，因为这是划分键值对的分隔符

目前脚本在实际处理中用到的关键字如下：

##### 目标文件地址关键字

```text
@TARGET=./target.txt
```

该关键字定义了该规则文件内的替换规则所对应的文件地址，允许使用绝对或相对地址，但请注意使用后者时需要向脚本提供根目录地址

可以有多个规则文件同时翻译同一个目标文件，但请注意目前无法定义规则文件的翻译顺序

所有的规则文件均需要该关键字，否则脚本将无法执行

##### 规则行分隔符关键字

规则行定义了替换规则，具体描述可以参考下文

与关键字类似，规则行也采用了`=`作为划分键值对的分隔符，但是硬编码的文本有时也会包含该分隔符，这将影响到规则文件的编写

因此，作为弥补，脚本允许通过该关键字来自定义规则行的分隔符，一个简单的例子如下：

```text
@DELIMITER=|
```

在添加了该关键字后，脚本接下来将使用`|`来划分规则行的键值对，但请注意，关键字行的分隔符永远都是`=`，无法被更改

通过该关键字，以及创建多个指向同一个目标文件的规则文件，便可以实现任意文本的替换

#### 注释行

注释行是用于放置提示性内容的部分，以`#`开头，一个简单的例子如下：

```text
# 这是一个注释行
#这也是一个注释行
```

注意当前脚本无法在其他行的后面添加注释：

```text
@KEYWORD_NAME=KEYWORD_VALUE  # 这不是注释，而是关键字的值的一部分
```

#### 规则行

规则行是规则文件的主体部分，默认情况下的分隔符是`=`，除非通过`DELIMITER`关键字进行了修改

规则行的构成即为简单，一个简单的例子如下：

```text
English=中文
Open=打开
```

以上的规则行共包括了两条替换规则，一个是将目标文件中的`English`替换为`中文`，另一个这是将目标文件中的`Open`替换为`打开`

注意替换不会报错，这意味着即使没有发生替换也不会通知

#### 完整的规则文件

一个参考的例子是：

```text
@AUTHOR=作者名称
@VERSION=1.0.0
@TARGET=./target.txt

# 注释行
'Yes'='是'
'No'='否'
```

请注意，规则文件中的关键字仅在文件开头有效：

```text
@AUTHOR=作者名称
@VERSION=1.0.0
@TARGET=./target.txt
@KEYWORD_1=这是一个关键字，因为处于文件开头

@KEYWORD_1=这是还是一个关键字，因为空行不影响解析

# 注释行
@NO_KEYWORD=这是不是一个关键字，因为已经有其他内容了，这个将作为规则行被解析
'Yes'='是'
'No'='否'
```

一个使用了`DELIMITER`关键字的例子：

```text
@AUTHOR=作者名称
@VERSION=1.0.0
@TARGET=./target.txt
@DELIMITER=|

# 注释行
'Yes'|'是'
'No'|'否'
English=中文
```

请注意，以上规则文件中的`English=中文`规则行将自动被跳过解析，因为无法被拆分为键值对，脚本在执行中会忽略所有错误的规则行

这是一个[可下载的规则文件](./rules/example.txt)，请随意下载并作为你的规则文件的起始

### 脚本的局限

- 包含规则文件的文件夹中不允许有其他无关文件，在未来可以添加一个跳过错误文件的开关
- 当前目标文件仅使用`utf-8`进行读取和保存，未来可以设计一个关键字来覆盖
- 规则行无法存在相同的替换规则，即无法对同一内容替换多次，目前暂时没有好的解决方案

### 使用该脚本的翻译项目

下面是一些使用该脚本进行翻译的项目，可以作为好的参考

- [Huginn-Chinese](https://github.com/yhdsl/Huginn-Chinese)

